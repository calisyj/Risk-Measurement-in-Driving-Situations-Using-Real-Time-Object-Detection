# Risk-Measurement-in-Driving-Situations-Using-Real-Time-Object-Detection  

[Report.pdf](https://github.com/calisyj/Risk-Measurement-in-Driving-Situations-Using-Real-Time-Object-Detection/files/11948941/Report.pdf)


[Uploading Code_for_hazard_score.ipynb…](){
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 19,
   "id": "5f4d3f0d",
   "metadata": {},
   "outputs": [],
   "source": [
    "#packages\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "import os\n",
    "import matplotlib.pyplot as plt\n",
    "import cv2 #computer vision module\n",
    "import re\n",
    "from statsmodels.tsa.ar_model import AutoReg # forecasting\n",
    "import statsmodels.api as sm\n",
    "import time\n",
    "import warnings"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "id": "3fb41ce6",
   "metadata": {},
   "outputs": [],
   "source": [
    "warnings.filterwarnings('ignore')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "628749c5",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Person bounding box object\n",
    "class Personbb:\n",
    "    def __init__(self,y_sup,y_inf):\n",
    "        self.coorDict = {}\n",
    "        self.trackDict = {}\n",
    "        self.labelDict = {}\n",
    "        self.timecount = 0\n",
    "        self.hazard_track_person = []\n",
    "        self.y_sup=y_sup\n",
    "        self.y_inf = y_inf\n",
    "        \n",
    "    #Printing method\n",
    "    def __str__(self):\n",
    "        return \"Current TrackDict: {}\".format(self.trackDict)\n",
    "    \n",
    "    #setter methods(for image & label)\n",
    "    def label_set(self,label_tuple):\n",
    "        self.xcentre,self.ycentre,self.bbwidth,self.bbheight = label_tuple\n",
    "        self.xmin = self.xcentre - self.bbwidth/2\n",
    "        self.xmax = self.xcentre + self.bbwidth/2\n",
    "        self.ymin = self.ycentre - self.bbheight/2\n",
    "        self.ymax = self.ycentre + self.bbheight/2\n",
    "    \n",
    "    def image_set(self,image_mat,candidate):\n",
    "        if candidate:\n",
    "            self.image_candidate = image_mat\n",
    "            self.height,self.width,_ = self.image_candidate.shape\n",
    "            \n",
    "        elif not candidate:\n",
    "            self.image = image_mat\n",
    "            self.height,self.width,_ = self.image.shape\n",
    "        self.midpoint = int(self.width/2)\n",
    "    \n",
    "    # 此函数将 YOLO 中使用的归一化坐标转换为像素坐标。\n",
    "    def change_coordinate(self):\n",
    "        self.xmin = int(self.width*self.xmin)\n",
    "        self.xmax = int(self.width*self.xmax)\n",
    "        self.ymin = int(max(self.height*self.ymin,self.y_inf))\n",
    "        self.ymax = int(min(self.height*self.ymax,self.y_sup))\n",
    "        self.labelDict[self.timecount+1] = (self.xmin,self.xmax,self.ymin,self.ymax)\n",
    "    \n",
    "    def move_coordinate(self):\n",
    "        self.height = self.y_sup\n",
    "        self.xmin_coord = self.xmin-self.midpoint\n",
    "        self.xmax_coord = self.xmax-self.midpoint\n",
    "        self.ymin_coord = self.height - (self.ymin)\n",
    "        self.ymax_coord = self.height - (self.ymax)\n",
    "        \n",
    "    def cut_image(self,candidate,upper_padding=250,lower_padding=270):\n",
    "        if candidate:\n",
    "            self.imagebb_can = self.image_candidate[(self.ymin):(self.ymax+1),self.xmin:(self.xmax+1)].copy()\n",
    "        elif not candidate:\n",
    "            self.imagebb = self.image[(self.ymin):(self.ymax+1),self.xmin:(self.xmax+1)].copy()\n",
    "            \n",
    "    #angle computing function    \n",
    "    def compute_angle(self):\n",
    "        self.standardVec = np.array([self.midpoint,self.height])\n",
    "        self.centerbbVec = np.array([int((self.xmax_coord)/2), int((self.ymin_coord+self.ymax_coord)/2)]) if abs(self.xmin_coord)>=self.xmax_coord else np.array([int((self.xmin_coord)/2), int((self.ymin_coord+self.ymax_coord)/2)])\n",
    "        self.downcentbbvec = np.array([int((self.xmin_coord+self.xmax_coord)/2),int(self.ymax_coord)]) \n",
    "        anglef = lambda Vec: np.arccos((np.dot(self.standardVec,Vec))/(np.sqrt(np.dot(self.standardVec,self.standardVec))*np.sqrt(np.dot(Vec,Vec)) ))*(180/np.pi)\n",
    "        if np.all(self.centerbbVec == np.zeros(2)) or np.all(self.downcentbbvec == np.zeros(2)):\n",
    "            self.angle = 0.0\n",
    "        else:\n",
    "            self.angle = anglef(self.centerbbVec) if anglef(self.centerbbVec) < anglef(self.downcentbbvec) else anglef(self.downcentbbvec)\n",
    "        \n",
    "    #euc-distance computing function\n",
    "    def compute_rawDistance(self,angle_sup=20):\n",
    "        if self.angle > angle_sup:\n",
    "            self.distance = np.sqrt(np.dot(self.centerbbVec,self.centerbbVec))\n",
    "        else:\n",
    "            self.distance = min(np.dot(self.centerbbVec,self.centerbbVec),np.sqrt(np.dot(self.downcentbbvec,self.downcentbbvec)))\n",
    "        \n",
    "    #표준편차는 gaussian function에서 변곡점과 관련 있다.\n",
    "    def fuzzy_gaussian_membership(self,x,mu,sigma):\n",
    "        return np.exp(-(x-mu)**2/(2*sigma**2))\n",
    "     \n",
    "    #새로 들어온 이미지 후보의 정보를 set. \n",
    "    def new_image_candidate(self,newim,newla):\n",
    "        self.image_set(newim,candidate=True)\n",
    "        self.label_set(newla)\n",
    "        self.change_coordinate()\n",
    "        self.cut_image(candidate=True)\n",
    "        \n",
    "    #매칭된 이미지 라벨을 저장 \n",
    "    def include_information(self):\n",
    "        self.timecount += 1\n",
    "        self.coorDict[self.timecount] = (self.xmin_coord,self.xmax_coord,self.ymax_coord,self.ymin_coord)\n",
    "        self.trackDict[self.timecount] = (self.angle,self.distance)\n",
    "        \n",
    "    def __call__(self,image,label,angle_sup=20):\n",
    "        self.label_set(label)\n",
    "        self.image_set(image,candidate=False)\n",
    "        self.change_coordinate()\n",
    "        self.cut_image(candidate=False)\n",
    "        self.move_coordinate()\n",
    "        self.compute_angle()\n",
    "        self.compute_rawDistance(angle_sup=angle_sup)\n",
    "        self.include_information()\n",
    "\n",
    "# Car bounding box class\n",
    "class Carbb(Personbb):\n",
    "    def __init__(self,y_sup,y_inf):\n",
    "        super().__init__(y_sup,y_inf)\n",
    "        self.hazard_track_car = []\n",
    "    \n",
    "    #speed computing function\n",
    "    def compute_relativeDelta(self,window_size=5):\n",
    "        self.delta = self.distance - self.trackDict[self.timecount][1] if len(self.trackDict)!=0 else 0\n",
    "        #computed moving average of the speed \n",
    "        self.delta = np.mean([self.delta]+[self.trackDict[i][1] for i in range(max(self.timecount-(window_size-1),1),self.timecount)])\n",
    "        \n",
    "    def include_information(self):\n",
    "        self.timecount += 1\n",
    "        self.coorDict[self.timecount] = (self.xmin_coord,self.xmax_coord,self.ymax_coord,self.ymin_coord)\n",
    "        self.trackDict[self.timecount] = (self.angle,self.distance,self.delta)\n",
    "        \n",
    "    #main method\n",
    "    def __call__(self,image,label,angle_sup=20):\n",
    "        self.label_set(label)\n",
    "        self.image_set(image,candidate=False)\n",
    "        self.change_coordinate()\n",
    "        self.cut_image(candidate=False)\n",
    "        self.move_coordinate()\n",
    "        self.compute_angle()\n",
    "        self.compute_rawDistance(angle_sup=angle_sup)\n",
    "        self.compute_relativeDelta()\n",
    "        self.include_information()   "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "id": "a66132ec",
   "metadata": {},
   "outputs": [],
   "source": [
    "# class for processing the Hazard Score\n",
    "class Processor:\n",
    "    \n",
    "    def __init__(self,directory,y_inf,y_sup):\n",
    "        \n",
    "        self.car_clslist = []\n",
    "        self.person_clslist = []\n",
    "        self.y_sup = y_sup\n",
    "        self.y_inf = y_inf\n",
    "        self.initial_put_car = True\n",
    "        self.initial_put_person = True\n",
    "        self.timestamp_car = 0\n",
    "        self.timestamp_person = 0\n",
    "        self.cemeteryCar = {} # 폐차장\n",
    "        self.cemeteryPerson = {} # 묘지\n",
    "        self.hazard_dict = {('LS','SA','SD'):'Moderate Risk',('LS','SA','MD'):'Moderate Risk',('LS','SA','LD'):'Low Risk',('MS','SA','SD'):'Dangerous!!',('MS','SA','MD'):'Moderate Risk',('MS','SA','LD'):'Moderate Risk',('HS','SA','SD'):'Dangerous!!',('HS','SA','MD'):'High Risk',('HS','SA','LD'):'Moderate Risk',('LS','MA','SD'):'Moderate Risk',('LS','MA','MD'):'Low Risk',('LS','MA','LD'):'Safe',('MS','MA','SD'):'High Risk',('MS','MA','MD'):'Moderate Risk',('MS','MA','LD'):'Low Risk',('HS','MA','SD'):'Dangerous!!',('HS','MA','MD'):'Moderate Risk',('HS','MA','LD'):'High Risk',('LS','LA','SD'):'Low Risk',('LS','LA','MD'):'Safe',('LS','LA','LD'):'Very Safe',('MS','LA','SD'):'High Risk',('MS','LA','MD'):'Low Risk',('MS','LA','LD'):'Safe',('HS','LA','SD'):'High Risk',('HS','LA','MD'):'Moderate Risk',('HS','LA','LD'):'Low Risk'}\n",
    "        self.video = cv2.VideoCapture(directory)\n",
    "        self.carDeckOpen = False\n",
    "        self.personDeckOpen = False\n",
    "        \n",
    "        \n",
    "    def derive_newImage(self,newLabel_path):\n",
    "        \n",
    "        self.newCarLabDict = {}\n",
    "        self.newPerLabDict = {}\n",
    "        with open(newLabel_path) as lab:\n",
    "            lines = lab.readlines()\n",
    "            car_no,per_no = (0,0)\n",
    "            for line in lines:\n",
    "                line_list = line.strip().split(' ')\n",
    "                if line_list[0] == '0': \n",
    "                    car_no += 1\n",
    "                    self.newCarLabDict[car_no] = (float(line_list[1]),float(line_list[2]),float(line_list[3]),float(line_list[4]))\n",
    "                    if self.initial_put_car:\n",
    "                        carbb_int = Carbb(y_sup=self.y_sup,y_inf=self.y_inf)\n",
    "                        #call function to adjust the label\n",
    "                        carbb_int(image=self.newimage,label=self.newCarLabDict[car_no])\n",
    "                        self.car_clslist.append(carbb_int)\n",
    "                        \n",
    "                elif line_list[0] == '1':\n",
    "                    \n",
    "                    if int(self.newimage.shape[0]*float(line_list[2]) )>self.y_inf:\n",
    "                        per_no += 1\n",
    "                        self.newPerLabDict[per_no] = (float(line_list[1]),float(line_list[2]),float(line_list[3]),float(line_list[4]))\n",
    "        \n",
    "                        if self.initial_put_person:\n",
    "                            personbb_int = Personbb(y_sup=self.y_sup,y_inf=self.y_inf)\n",
    "                            personbb_int(image=self.newimage,label=self.newPerLabDict[per_no])\n",
    "                            self.person_clslist.append(personbb_int)\n",
    "                        \n",
    "            self.initial_put_car = True if len(self.car_clslist)==0 else False\n",
    "            self.initial_put_person = True if len(self.person_clslist)==0 else False\n",
    "\n",
    "        \n",
    "    def distinguish_label_type(self,label_type='car'):\n",
    "        if label_type == 'car':\n",
    "            self.imgs = [cls.image[cls.ymin:(self.y_sup+1),cls.xmin:(cls.xmax+1)].copy() if cls.ymax > self.y_sup  else cls.image[self.y_inf:(cls.ymax+1),cls.xmin:(cls.xmax+1)].copy() if cls.ymin < self.y_inf else cls.imagebb for cls in self.car_clslist]\n",
    "        \n",
    "        elif label_type == 'person':\n",
    "            self.imgs = [cls.image[cls.ymin:(self.y_sup+1),cls.xmin:(cls.xmax+1)].copy() if cls.ymax > self.y_sup else cls.image[self.y_inf:(cls.ymax+1),cls.xmin:(cls.xmax+1)].copy() if cls.ymin < self.y_inf else cls.imagebb for cls in self.person_clslist]\n",
    "        \n",
    "    #letting the computer know whether the objects from different time points are the same or not\n",
    "    def compute_similarities(self,label_type='car',similarity_threshold=0.45):\n",
    "        #BGR\n",
    "        hist_list = [ cv2.calcHist([cv2.cvtColor(im_kind,cv2.COLOR_BGR2HSV)],[0,1],None,[180,256],[0,180,0,256]) for im_kind in self.imgs ]\n",
    "        class_list = self.car_clslist if label_type == 'car' else self.person_clslist\n",
    "        query_dict = self.newCarLabDict if label_type == 'car' else self.newPerLabDict\n",
    "        #methods = {'CORREL' :cv2.HISTCMP_CORREL, 'CHISQR':cv2.HISTCMP_CHISQR, 'INTERSECT':cv2.HISTCMP_INTERSECT,'BHATTACHARYYA':cv2.HISTCMP_BHATTACHARYYA}\n",
    "        ret = np.zeros(len(hist_list)).reshape(1,len(hist_list))\n",
    "        if len(class_list)!=0 and len(query_dict) != 0:\n",
    "            for i,label in query_dict.items():\n",
    "                for cls in class_list:\n",
    "                    cls.new_image_candidate(self.newimage,label)\n",
    "                query = cv2.calcHist([cv2.cvtColor(class_list[0].imagebb_can,cv2.COLOR_BGR2HSV)],[0,1],None,[180,256],[0,180,0,256])\n",
    "                ret = np.concatenate((ret,np.array([[cv2.compareHist(query,hist,cv2.HISTCMP_CORREL) for hist in hist_list]])))\n",
    "\n",
    "            ret = ret[1:,:]\n",
    "            \n",
    "            whole_arr,selected_arr = (np.arange(ret.shape[0]),np.argmax(ret,axis=0))\n",
    "            unselected_arr = np.setdiff1d(whole_arr,selected_arr)\n",
    "            \n",
    "            include_list = []\n",
    "            if label_type == 'car':\n",
    "                self.timestamp_car += 1\n",
    "                self.cemeteryCar[self.timestamp_car] = []\n",
    "                \n",
    "            elif label_type == 'person':\n",
    "                self.timestamp_person += 1\n",
    "                self.cemeteryPerson[self.timestamp_person] = []\n",
    "                \n",
    "            for i,(cl,sel_ind) in enumerate(zip(class_list,list(selected_arr))):\n",
    "                if (ret[sel_ind,i] >= similarity_threshold) & (ret[sel_ind,i]== np.max(ret[:,i])):\n",
    "                    cl(self.newimage,query_dict[sel_ind+1])\n",
    "                    include_list.append(i)\n",
    "                else:\n",
    "                    if label_type == 'car':\n",
    "                        self.cemeteryCar[self.timestamp_car].append(class_list[i])\n",
    "                    elif label_type == 'person':\n",
    "                        self.cemeteryPerson[self.timestamp_person].append(class_list[i])\n",
    "                \n",
    "            \n",
    "                    \n",
    "            class_list = [class_list[i] for i in include_list]   \n",
    "\n",
    "            if len(unselected_arr) != 0:\n",
    "                for unsel_ind in unselected_arr:\n",
    "                    inst = Carbb(y_sup=self.y_sup,y_inf=self.y_inf) if label_type == 'car' else Personbb(y_sup=self.y_sup,y_inf=self.y_inf)\n",
    "                    inst(self.newimage,query_dict[unsel_ind+1])\n",
    "                    class_list.append(inst)\n",
    "        elif len(class_list)==0 and len(query_dict) != 0:\n",
    "            for k,val in query_dict.items():\n",
    "                inst = Carbb(y_sup=self.y_sup,y_inf=self.y_inf) if label_type == 'car' else Personbb(y_sup=self.y_sup,y_inf=self.y_inf)\n",
    "                inst(self.newimage,val)\n",
    "                class_list.append(inst)\n",
    "        else:\n",
    "            return 'End'\n",
    "            \n",
    "        if label_type == 'car':\n",
    "            self.car_clslist = class_list\n",
    "            \n",
    "        elif label_type == 'person':\n",
    "            self.person_clslist = class_list\n",
    "    #unpredictability calculating method\n",
    "    def time_series_forecast(self,label_type='car',lags=4,interval_lower=5,interval_upper=15):\n",
    "        \n",
    "        class_df = pd.DataFrame({'class':self.car_clslist}) if label_type == 'car' else pd.DataFrame({'class':self.person_clslist})\n",
    "        class_df = class_df.reset_index()\n",
    "        \n",
    "        def assign_vals(x,label_type):\n",
    "            df = pd.DataFrame()\n",
    "            if len(x['class'].trackDict) >= interval_lower and len(x['class'].trackDict) <= interval_upper:\n",
    "                df['distance_p'] = list(map(lambda x: x[1],list(x['class'].trackDict.values()) ))\n",
    "                df['angle_p'] = list(map(lambda x: x[0],list(x['class'].trackDict.values())))\n",
    "                if label_type == 'car':\n",
    "                    df['speed_p'] = list(map(lambda x: x[2],list(x['class'].trackDict.values())) )\n",
    "                \n",
    "                df.reset_index(inplace=True)\n",
    "                df['ds'] = pd.to_datetime(df['index'])\n",
    "                train_df = df.iloc[:-1,:]\n",
    "                test_df = df.iloc[-1,:]\n",
    "                \n",
    "                pred_uncertainity = []\n",
    "                element_list = ['distance_p','angle_p','speed_p'] if label_type == 'car' else ['distance_p','angle_p']\n",
    "                \n",
    "                for col in element_list:\n",
    "                    \n",
    "                    fit_df = train_df.loc[:,['ds',col]].rename({col:'y'},axis=1)\n",
    "                    \n",
    "                    fit_test_df = test_df[['ds',col]].rename({col:'y'})\n",
    "                    fit_test_df = pd.DataFrame({'ds':[fit_test_df['ds']],'y':[fit_test_df['y']]})\n",
    "                    \n",
    "                    \n",
    "                    try:\n",
    "                        m = AutoReg(train_df[col],lags=lags,seasonal=False,period=len(train_df[col])).fit()\n",
    "                    \n",
    "                    except:\n",
    "                        m = AutoReg(train_df[col],lags=1,seasonal=False,period=len(train_df[col])).fit()\n",
    "                        \n",
    "                        \n",
    "                    predicted_y = m.predict(start=fit_df.shape[0],end=fit_df.shape[0],dynamic=False).iloc[0]\n",
    "                    \n",
    "                    \n",
    "                    y_bar = np.mean(train_df[col].iloc[:(interval_lower)]) if col != 'speed_p' else np.mean(train_df[col])\n",
    "                    #calculation of unpredictability(0~1)\n",
    "                    unpredictability = ((fit_test_df['y'].iloc[0]-predicted_y)<=0)*(abs(fit_test_df['y'].iloc[0]-predicted_y))/(abs(fit_test_df['y'].iloc[0]-predicted_y)+abs(predicted_y-y_bar)+1e-05) if col != 'speed_p' else ((fit_test_df['y'].iloc[0]-predicted_y)>0)*abs((fit_test_df['y'].iloc[0]-predicted_y))/(abs(fit_test_df['y'].iloc[0]-predicted_y)+abs(predicted_y-y_bar)+1e-05)\n",
    "                    pred_uncertainity.append(unpredictability)\n",
    "\n",
    "                if label_type == 'car':\n",
    "                    x['distance_p'],x['angle_p'],x['speed_p'] = (pred_uncertainity[0],pred_uncertainity[1],pred_uncertainity[2])\n",
    "                    #x['distance_p'],x['angle_p'],x['speed_p'] = (1,pred_uncertainity[0],1 )\n",
    "                    return x[['distance_p','angle_p','speed_p']]\n",
    "                else:\n",
    "                    x['distance_p'],x['angle_p'] = (pred_uncertainity[0],pred_uncertainity[1])\n",
    "                    return x[['distance_p','angle_p']]\n",
    "            else: \n",
    "                if label_type == 'car':\n",
    "                    x['distance_p'],x['angle_p'],x['speed_p'] = (-1,-1,-1)\n",
    "                    return x[['distance_p','angle_p','speed_p']]\n",
    "                else:\n",
    "                    x['distance_p'],x['angle_p'] = (-1,-1)\n",
    "                    return x[['distance_p','angle_p']] \n",
    "        if label_type == 'car':\n",
    "            self.unpredDf_car = class_df.apply(assign_vals,label_type=label_type,axis=1)\n",
    "            \n",
    "        else:\n",
    "            self.unpredDf_person = class_df.apply(assign_vals,label_type=label_type,axis=1)\n",
    "            \n",
    "        \n",
    "        \n",
    "    \n",
    "    def fuzzy_gaussian_membership(self,x,mu,sigma): #parametres(mean,standard deviation) must be scalars\n",
    "        return np.exp(-(x-mu)**2/(2*sigma**2))\n",
    "    \n",
    "    def fuzzy_logistic_membership(self,x,mu,sigma):\n",
    "        return 1/(1+np.exp(-(x-mu)/sigma))\n",
    "    \n",
    "    #computes physical risk factors(distance,angle,speed)\n",
    "    def compute_hazard_rate(self,angle_tol=20,k=5,boot_sample=2000,label_type='car',cold_start_t=2,aggfunc=np.mean):\n",
    "        \n",
    "        class_list = self.car_clslist if label_type == 'car' else self.person_clslist\n",
    "        cemetery_dict = self.cemeteryCar if label_type == 'car' else self.cemeteryPerson\n",
    "        global_timestamp = self.timestamp_car if label_type == 'car' else self.timestamp_person \n",
    "        \n",
    "        interval_list = list(map(lambda cls: (cls.timecount-k+1,cls.timecount) if (cls.timecount >= cold_start_t) & (cls.timecount >= k) else (1,cls.timecount) if (cls.timecount>=cold_start_t) & (cls.timecount<k) else (0,0) ,class_list))\n",
    "        \n",
    "        cemetery_list = list(map(lambda y: y[1],list(cemetery_dict.items())[(global_timestamp-k):(global_timestamp)]))\n",
    "        \n",
    "        prior_list = []\n",
    "        for ele in cemetery_list:\n",
    "            prior_list += ele\n",
    "        \n",
    "        if (len(interval_list)!=0) and (len(class_list)!=0): \n",
    "            \n",
    "            if label_type == 'car':\n",
    "                \n",
    "                #self.carDeckOpen = True\n",
    "                track_list = [ ele[1]  if end != 0 else (-9999,-9999,-9999) for cls,(start,end) in zip(class_list,interval_list) for ele in list(cls.trackDict.items())[(start-1):end]]\n",
    "    \n",
    "                distance_list,angle_list,speed_list= [elements[1] for elements in track_list],[elements[0] for elements in track_list] ,[elements[2] for elements in track_list]\n",
    "                \n",
    "                prior_dist_list,_,prior_speed_list = list(map(lambda h: list(h.trackDict.items())[0][1][1],prior_list)),0,list(map(lambda h: list(h.trackDict.items())[0][1][2],prior_list))\n",
    "                \n",
    "                dist_arr,speed_arr = np.array(prior_dist_list+[element if element!= -9999 else None for element in distance_list]),np.array(prior_speed_list+[element if element!= -9999 else None for element in speed_list])\n",
    "                try:\n",
    "                    self.carDeckOpen = True\n",
    "                    dist_sigma,speed_sigma = aggfunc(np.random.choice(dist_arr,boot_sample)),aggfunc(np.abs(np.random.choice(speed_arr,boot_sample)))\n",
    "                    dist_hazard_list = [self.fuzzy_gaussian_membership(cls.trackDict[len(cls.trackDict)][1],mu=0,sigma=sigma) if cls.trackDict[len(cls.trackDict)][1] != -9999 else -1 for cls,sigma in zip(self.car_clslist,np.repeat(dist_sigma,len(self.car_clslist)) )]\n",
    "                    angle_hazard_list = [self.fuzzy_gaussian_membership(cls.trackDict[len(cls.trackDict)][0],mu=0,sigma=sigma) if cls.trackDict[len(cls.trackDict)][0] != -9999 else -1 for cls,sigma in zip(self.car_clslist,np.repeat(angle_tol,len(self.car_clslist)) )]\n",
    "                    speed_hazard_list = [self.fuzzy_logistic_membership(cls.trackDict[len(cls.trackDict)][2],mu=0,sigma=sigma) if cls.trackDict[len(cls.trackDict)][2] != -9999 else -1 for cls,sigma in zip(self.car_clslist,np.repeat(speed_sigma,len(self.car_clslist)) )]\n",
    "                    self.hazard_df_car = pd.DataFrame({'distance_hazard':dist_hazard_list,'angle_hazard':angle_hazard_list,'speed_hazard':speed_hazard_list})\n",
    "                except:\n",
    "                    pass\n",
    "\n",
    "            elif label_type == 'person':\n",
    "                \n",
    "                \n",
    "                track_list = [ ele[1]  if end != 0 else (-9999,-9999,-9999) for cls,(start,end) in zip(class_list,interval_list) for ele in list(cls.trackDict.items())[(start-1):end]]\n",
    "    \n",
    "                distance_list,angle_list = [elements[1] for elements in track_list],[elements[0] for elements in track_list]\n",
    "                prior_dist_list = list(map(lambda h: list(h.trackDict.items())[0][1][1],prior_list))\n",
    "                \n",
    "                dist_arr = np.array(prior_dist_list+[element if element!= -9999 else None for element in distance_list])\n",
    "                try:\n",
    "                    self.personDeckOpen = True\n",
    "                    dist_sigma = aggfunc(np.random.choice(dist_arr,boot_sample))\n",
    "                    dist_hazard_list = [self.fuzzy_gaussian_membership(cls.trackDict[len(cls.trackDict)][1],mu=0,sigma=sigma) if cls.trackDict[len(cls.trackDict)][1] != -9999 else -1 for cls,sigma in zip(self.person_clslist,np.repeat(dist_sigma,len(self.person_clslist)) )]\n",
    "                    angle_hazard_list = [self.fuzzy_gaussian_membership(cls.trackDict[len(cls.trackDict)][0],mu=0,sigma=sigma) if cls.trackDict[len(cls.trackDict)][0] != -9999 else -1 for cls,sigma in zip(self.person_clslist,np.repeat(angle_tol,len(self.person_clslist)) )]\n",
    "\n",
    "                    self.hazard_df_person = pd.DataFrame({'distance_hazard':dist_hazard_list,'angle_hazard':angle_hazard_list})\n",
    "                except:\n",
    "                    pass\n",
    "    def __call__(self,ms,wh_tuple=(500,500),alpha=0.15,frame_div=3,interval_lower=5,interval_upper=15,label_root='Desktop/labels',sort_needed=True,boundary_chr=('_', re.escape('.')),dist_threshold=(0.3,0.7),angle_threshold=(0.3,0.7),speed_threshold=(0.3,0.6),similarity_threshold=0.5,angle_tol=20,k=10,boot_sample=500,cold_start_t=3,aggfunc=np.median):\n",
    "        count = 0\n",
    "        label = os.listdir(label_root)\n",
    "        if sort_needed:\n",
    "            label = os.listdir(label_root)\n",
    "            label.sort(key=lambda v: int(re.compile('{}(.*){}'.format(boundary_chr[0],boundary_chr[1])).findall(v)[0]) )\n",
    "\n",
    "        \n",
    "        while (count < (len(label)-1)):\n",
    "            count += 1\n",
    "            \n",
    "            ret,self.newimage = self.video.read()\n",
    "            height,width,_ = self.newimage.shape\n",
    "            \n",
    "            #self.newimage = cv2.resize(self.newimage,wh_tuple,cv2.INTER_LINEAR)\n",
    "        \n",
    "            if (count % frame_div)==0:\n",
    "                self.derive_newImage(label_root+'/'+label[count])\n",
    "                \n",
    "                self.distinguish_label_type(label_type='car')\n",
    "                #car label hazard rate compute process\n",
    "                #if len(self.car_clslist)!=0 and len(self.imgs)!=0:\n",
    "                \n",
    "                if len(self.newPerLabDict)!=0:\n",
    "                    res = self.compute_similarities(label_type='car',similarity_threshold=similarity_threshold)\n",
    "\n",
    "                if (self.timestamp_car > cold_start_t) and len(self.car_clslist)!=0:\n",
    "                    self.compute_hazard_rate(label_type='car',angle_tol=angle_tol,k=k,boot_sample=boot_sample,cold_start_t=cold_start_t,aggfunc=aggfunc)\n",
    "                \n",
    "                if (self.timestamp_car > cold_start_t) and (self.carDeckOpen) and len(self.car_clslist)!=0:\n",
    "                    self.time_series_forecast(interval_lower=interval_lower,interval_upper=interval_upper)\n",
    "\n",
    "                    #폰트 지정\n",
    "                    font =  cv2.FONT_ITALIC\n",
    "\n",
    "                    car_hazard = pd.concat([self.hazard_df_car.reset_index(drop=True),self.unpredDf_car.reset_index(drop=True)],axis=1).apply(lambda x: (x.iloc[0]+x.iloc[1]+x.iloc[2])/3 if x.iloc[3]< 0 else (min(x.iloc[0]+alpha*x.iloc[3],1)+min(x.iloc[1]*alpha*x.iloc[4],1)+min(x.iloc[2]*alpha*x.iloc[5],1) )/3 ,axis=1)\n",
    "                    car_hazard.reset_index(drop=True,inplace=True)\n",
    "                    car_hazard2 = []\n",
    "                    for haz,sel_cls in zip(list(car_hazard),self.car_clslist):\n",
    "                        sel_cls.hazard_track_car.append(haz)\n",
    "                        car_hazard2.append(np.max(sel_cls.hazard_track_car[-min(len(sel_cls.hazard_track_car),5):]) )\n",
    "\n",
    "                    Df = pd.DataFrame({'class':self.car_clslist,'hazard':car_hazard2})\n",
    "                    cls_list = Df.sort_values('hazard',ascending=False)['class'].iloc[:min(len(self.car_clslist),7)]\n",
    "\n",
    "\n",
    "                    for i,clss in enumerate(cls_list):\n",
    "\n",
    "                        if self.hazard_df_car['distance_hazard'].iloc[i]>=0 and car_hazard2[i]>=0.6:\n",
    "                            xmin,xmax,ymin,ymax= clss.labelDict[clss.timecount]\n",
    "\n",
    "                            \n",
    "                            # 이미지에 위험도 수치 텍스트로 합성\n",
    "\n",
    "                            \n",
    "                            dist_discrim = 'SD' if self.hazard_df_car['distance_hazard'].iloc[i] >= dist_threshold[1] else 'LD' if self.hazard_df_car['distance_hazard'].iloc[i] <= dist_threshold[0] else 'MD'\n",
    "                            angle_discrim = 'SA' if self.hazard_df_car['angle_hazard'].iloc[i] >= angle_threshold[1] else 'LA' if self.hazard_df_car['angle_hazard'].iloc[i] <= angle_threshold[0] else 'MA'\n",
    "                            speed_discrim = 'HS' if self.hazard_df_car['speed_hazard'].iloc[i] >= speed_threshold[1] else 'LS' if self.hazard_df_car['speed_hazard'].iloc[i] <= speed_threshold[0] else 'MS'\n",
    "\n",
    "                            res_discrim = self.hazard_dict[(speed_discrim,angle_discrim,dist_discrim)]\n",
    "\n",
    "                            if res_discrim ==\"Dangerous!!\" and car_hazard2[i] >= 0.85:\n",
    "                                self.newimage[ymin:ymax,xmin:xmax,0] = 0\n",
    "                                self.newimage[ymin:ymax,xmin:xmax,1] = 0\n",
    "                                self.newimage = cv2.arrowedLine(self.newimage,(int(clss.width/2),clss.height),(int((xmin+xmax)/2),int((ymin+ymax)/2)),(0,round(0*(1-car_hazard2[i])),max(225,round(255*car_hazard2[i]))),2) \n",
    "                                self.newimage = cv2.putText(self.newimage,'Dangerous!',(int((xmin+xmax)/2),int((ymin+ymax)/2-40)), font, 1.5, (0,round(0*(1-car_hazard2[i])),max(225,round(255*car_hazard2[i]))), 3, cv2.LINE_AA)\n",
    "                                self.newimage = cv2.putText(self.newimage,\"{}\".format(round(car_hazard2[i]*100) ),(int((xmin+xmax)/2),int((ymin+ymax)/2)), font, 1.5, (255,255,255), 3, cv2.LINE_AA)\n",
    "\n",
    "                            elif res_discrim == \"High Risk\" and car_hazard2[i] >= 0.8:\n",
    "                                self.newimage[ymin:ymax,xmin:xmax,0] = 0\n",
    "                                self.newimage[ymin:ymax,xmin:xmax,1] = 0\n",
    "                                self.newimage = cv2.arrowedLine(self.newimage,(int(clss.width/2),clss.height),(int((xmin+xmax)/2),int((ymin+ymax)/2)),(0,round(50*(1-car_hazard2[i])),max(200,round(255*car_hazard2[i]))),2) \n",
    "                                self.newimage = cv2.putText(self.newimage,'Risky!',(int((xmin+xmax)/2),int((ymin+ymax)/2-40)), font, 1.5, (0,round(50*(1-car_hazard2[i])),max(200,round(255*car_hazard2[i]))), 3, cv2.LINE_AA)\n",
    "                                self.newimage = cv2.putText(self.newimage,\"{}\".format(round(car_hazard2[i]*100) ),(int((xmin+xmax)/2),int((ymin+ymax)/2)), font, 1.5, (255,255,255), 3, cv2.LINE_AA)\n",
    "\n",
    "                            elif car_hazard2[i] >= 0.7:\n",
    "                                self.newimage = cv2.arrowedLine(self.newimage,(int(clss.width/2),clss.height),(int((xmin+xmax)/2),int((ymin+ymax)/2)),(0,round(175*(1-car_hazard2[i])),max(50,round(255*car_hazard2[i]))),2) \n",
    "                                self.newimage = cv2.putText(self.newimage,'Look Out!',(int((xmin+xmax)/2),int((ymin+ymax)/2-40)), font, 1.5, (0,round(175*(1-car_hazard2[i])),max(50,round(255*car_hazard2[i]))), 2, cv2.LINE_AA)\n",
    "                                self.newimage = cv2.putText(self.newimage,\"{}\".format(round(car_hazard2[i]*100) ),(int((xmin+xmax)/2),int((ymin+ymax)/2)), font, 1.5, (255,255,255), 3, cv2.LINE_AA)\n",
    "\n",
    "                            elif  car_hazard2[i] >= 0.6:\n",
    "                                self.newimage = cv2.arrowedLine(self.newimage,(int(clss.width/2),clss.height),(int((xmin+xmax)/2),int((ymin+ymax)/2)),(0,round(255*(1-car_hazard2[i])),max(25,round(255*car_hazard2[i]))),2) \n",
    "                                self.newimage = cv2.putText(self.newimage,'Look Out!',(int((xmin+xmax)/2),int((ymin+ymax)/2-40)), font,1.5, (0,round(255*(1-car_hazard2[i])),max(25,round(255*car_hazard2[i]))), 2, cv2.LINE_AA)\n",
    "                                self.newimage = cv2.putText(self.newimage,\"{}\".format(round(car_hazard2[i]*100) ),(int((xmin+xmax)/2),int((ymin+ymax)/2)), font, 1.5, (255,255,255), 3, cv2.LINE_AA)\n",
    "\n",
    "                                \n",
    "\n",
    "                    #person label hazard rate compute process\n",
    "\n",
    "                \n",
    "                \n",
    "                self.distinguish_label_type(label_type='person')\n",
    "                    \n",
    "                if len(self.person_clslist)>=1 and len(self.newPerLabDict)!=0:\n",
    "                    self.compute_similarities(label_type='person',similarity_threshold=similarity_threshold)\n",
    "                if (self.timestamp_person > cold_start_t) and len(self.person_clslist)>=1:\n",
    "                    self.compute_hazard_rate(label_type='person',angle_tol=angle_tol,k=k,boot_sample=boot_sample,cold_start_t=cold_start_t,aggfunc=aggfunc)\n",
    "\n",
    "                if (self.timestamp_person > cold_start_t) and (self.personDeckOpen) and len(self.person_clslist)>=1:\n",
    "\n",
    "                    #self.compute_hazard_rate(label_type='person',angle_tol=angle_tol,k=k,boot_sample=boot_sample,cold_start_t=cold_start_t,aggfunc=aggfunc)\n",
    "                    self.time_series_forecast(interval_lower=interval_lower,interval_upper=interval_upper,label_type='person')\n",
    "\n",
    "                    \n",
    "                    #폰트 지정\n",
    "                    font =  cv2.FONT_ITALIC\n",
    "\n",
    "                    person_hazard = pd.concat([self.hazard_df_person.reset_index(drop=True),self.unpredDf_person.reset_index(drop=True)],axis=1).apply(lambda x: (x.iloc[0]+x.iloc[1])/2 if x.iloc[2]< 0 else (min(x.iloc[0]+alpha*x.iloc[2],1)+min(x.iloc[1]+alpha*x.iloc[3],1))/2 ,axis=1)\n",
    "                    person_hazard.reset_index(drop=True,inplace=True)\n",
    "                    person_hazard2 = []\n",
    "                    for haz,sel_cls in zip(list(person_hazard),self.person_clslist):\n",
    "                        sel_cls.hazard_track_person.append(haz)\n",
    "                        person_hazard2.append(np.max(sel_cls.hazard_track_person[-min(len(sel_cls.hazard_track_person),2):]) )\n",
    "\n",
    "                    Df = pd.DataFrame({'class':self.person_clslist,'hazard':person_hazard2})\n",
    "                    cls_list = Df.sort_values('hazard',ascending=False)['class'].iloc[:min(len(self.person_clslist),5)]\n",
    "\n",
    "                    try:\n",
    "                        for i,clss in enumerate(cls_list):\n",
    "\n",
    "                            if self.hazard_df_person['distance_hazard'].iloc[i]>=0 and person_hazard2[i]>=0.6:\n",
    "                                xmin,xmax,ymin,ymax= clss.labelDict[clss.timecount]\n",
    "                                #self.newimage = cv2.arrowedLine(self.newimage,(int(clss.width/2),clss.height),(int((xmin+xmax)/2),int((ymin+ymax)/2)),(0,round(255*(1-car_hazard[i])),max(175,round(255*car_hazard[i]))),2) \n",
    "\n",
    "                                # 이미지에 위험도 수치 텍스트로 합성\n",
    "\n",
    "                                #self.newimage = cv2.putText(self.newimage,\"{}\".format(round(car_hazard[i]*100) ),(int((xmin+xmax)/2),int((ymin+ymax)/2)), font, 1.5, (255,255,255), 3, cv2.LINE_AA)\n",
    "\n",
    "                                dist_discrim = 'SD' if self.hazard_df_person['distance_hazard'].iloc[i] >= dist_threshold[1] else 'LD' if self.hazard_df_person['distance_hazard'].iloc[i] <= dist_threshold[0] else 'MD'\n",
    "                                angle_discrim = 'SA' if self.hazard_df_car['angle_hazard'].iloc[i] >= angle_threshold[1] else 'LA' if self.hazard_df_car['angle_hazard'].iloc[i] <= angle_threshold[0] else 'MA'\n",
    "                                speed_discrim = 'HS' #penalty as High speed  \n",
    "                                res_discrim = self.hazard_dict[(speed_discrim,angle_discrim,dist_discrim)]\n",
    "\n",
    "                                if res_discrim ==\"Dangerous!!\" and person_hazard2[i] >= 0.9:\n",
    "                                    self.newimage[ymin:ymax,xmin:xmax,0] = 0\n",
    "                                    self.newimage[ymin:ymax,xmin:xmax,1] = 0\n",
    "                                    self.newimage = cv2.arrowedLine(self.newimage,(int(clss.width/2),clss.height),(int((xmin+xmax)/2),int((ymin+ymax)/2)),(0,round(0*(1-person_hazard2[i])),max(225,round(255*person_hazard2[i]))),2) \n",
    "                                    self.newimage = cv2.putText(self.newimage,'Dangerous!',(int((xmin+xmax)/2),int((ymin+ymax)/2-40)), font, 1.5, (0,round(0*(1-person_hazard2[i])),max(225,round(255*person_hazard2[i]))), 3, cv2.LINE_AA)\n",
    "                                    self.newimage = cv2.putText(self.newimage,\"{}\".format(round(person_hazard2[i]*100) ),(int((xmin+xmax)/2),int((ymin+ymax)/2)), font, 1.5, (255,255,255), 3, cv2.LINE_AA)\n",
    "\n",
    "                                elif res_discrim == \"High Risk\" and person_hazard2[i] >= 0.85:\n",
    "                                    self.newimage[ymin:ymax,xmin:xmax,0] = 0\n",
    "                                    self.newimage[ymin:ymax,xmin:xmax,1] = 0\n",
    "                                    self.newimage = cv2.arrowedLine(self.newimage,(int(clss.width/2),clss.height),(int((xmin+xmax)/2),int((ymin+ymax)/2)),(0,round(50*(1-person_hazard2[i])),max(200,round(255*car_hazard2[i]))),2) \n",
    "                                    self.newimage = cv2.putText(self.newimage,'Risky!',(int((xmin+xmax)/2),int((ymin+ymax)/2-40)), font, 1.5, (0,round(50*(1-person_hazard2[i])),max(200,round(255*person_hazard2[i]))), 3, cv2.LINE_AA)\n",
    "                                    self.newimage = cv2.putText(self.newimage,\"{}\".format(round(person_hazard2[i]*100) ),(int((xmin+xmax)/2),int((ymin+ymax)/2)), font, 1.5, (255,255,255), 3, cv2.LINE_AA)\n",
    "\n",
    "                                elif person_hazard2[i] >= 0.7:\n",
    "                                    self.newimage = cv2.arrowedLine(self.newimage,(int(clss.width/2),clss.height),(int((xmin+xmax)/2),int((ymin+ymax)/2)),(0,round(175*(1-person_hazard2[i])),max(50,round(255*person_hazard2[i]))),2) \n",
    "                                    self.newimage = cv2.putText(self.newimage,'Look Out!',(int((xmin+xmax)/2),int((ymin+ymax)/2-40)), font, 1.5, (0,round(175*(1-person_hazard2[i])),max(50,round(255*person_hazard2[i]))), 2, cv2.LINE_AA)\n",
    "                                    self.newimage = cv2.putText(self.newimage,\"{}\".format(round(person_hazard2[i]*100) ),(int((xmin+xmax)/2),int((ymin+ymax)/2)), font, 1.5, (255,255,255), 3, cv2.LINE_AA)\n",
    "\n",
    "                                elif person_hazard2[i] >= 0.6:\n",
    "                                    self.newimage = cv2.arrowedLine(self.newimage,(int(clss.width/2),clss.height),(int((xmin+xmax)/2),int((ymin+ymax)/2)),(0,round(255*(1-person_hazard2[i])),max(25,round(255*person_hazard2[i]))),2) \n",
    "                                    self.newimage = cv2.putText(self.newimage,'Look Out!',(int((xmin+xmax)/2),int((ymin+ymax)/2-40)), font,1.5, (0,round(255*(1-person_hazard2[i])),max(25,round(255*person_hazard2[i]))), 2, cv2.LINE_AA)\n",
    "                                    self.newimage = cv2.putText(self.newimage,\"{}\".format(round(person_hazard2[i]*100) ),(int((xmin+xmax)/2),int((ymin+ymax)/2)), font, 1.5, (255,255,255), 3, cv2.LINE_AA)\n",
    "\n",
    "                    except:\n",
    "                        pass\n",
    "                self.newimage = cv2.resize(self.newimage,wh_tuple,cv2.INTER_LINEAR)\n",
    "                cv2.imshow('object detection',self.newimage)\n",
    "                cv2.waitKey(ms)\n",
    "                \n",
    "        self.video.release()\n",
    "        cv2.destroyAllWindows()\n",
    "        "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "id": "0f4a7617",
   "metadata": {},
   "outputs": [],
   "source": [
    "#testing 1\n",
    "pro = Processor(directory='Desktop/2.mp4',y_inf=300,y_sup=810)\n",
    "pro(ms=50,wh_tuple=(700,700),frame_div=1,sort_needed=True,label_root='Desktop/labels',alpha=0.2,interval_lower=7,angle_tol=40,interval_upper=2000,k=30,similarity_threshold=0.55,aggfunc=np.median)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "id": "3b8834f5",
   "metadata": {},
   "outputs": [],
   "source": [
    "#testing 2\n",
    "pro = Processor(directory='Desktop/detect/exp5/5.mp4',y_inf=300,y_sup=810)\n",
    "pro(ms=30,wh_tuple=(700,700),frame_div=1,sort_needed=True,label_root='Desktop/detect/exp5/labels',alpha=0.2,interval_lower=7,angle_tol=40,interval_upper=2000,k=30,similarity_threshold=0.55,aggfunc=np.median)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "id": "a3d66f1f",
   "metadata": {},
   "outputs": [],
   "source": [
    "#testing 3\n",
    "pro = Processor(directory='Desktop/detect/exp6/6.mp4',y_inf=500,y_sup=1400)\n",
    "pro(ms=300,wh_tuple=(700,700),frame_div=1,sort_needed=True,label_root='Desktop/detect/exp6/labels',alpha=0.2,interval_lower=7,angle_tol=40,interval_upper=2000,k=30,similarity_threshold=0.55,aggfunc=np.median)\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.12"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}

